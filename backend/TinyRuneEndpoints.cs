// In TinyRuneEndpoints.cs
using System.Data;
using System.Text;
using System.Text.Json.Nodes;
using Dapper;

public static class TinyRuneEndpoints
{
    public static void MapRuneEndpoints(this IEndpointRouteBuilder app)
    {
        var runeGroup = app.MapGroup("/rune");

        runeGroup.MapPost("/{tenantId:guid}/register/{tableName}",
        async (Guid tenantId, string tableName, JsonObject schemaBody, IDbConnection db) =>
        {
            // Sanitize table name to prevent SQL injection in table names
            var safeTableName = $"{tenantId}_{tableName.Replace(";", "")}";

            var columns = new List<string> { "`Id` INTEGER PRIMARY KEY AUTOINCREMENT" };

            // Parse the JSON schema to build column definitions
            foreach (var property in schemaBody["properties"]!.AsObject())
            {
                var columnName = property.Key;
                var type = property.Value!["type"]!.GetValue<string>();

                var sqlType = type switch
                {
                    "string" => "TEXT",
                    "integer" => "INTEGER",
                    "number" => "REAL", // For floating-point numbers
                    "boolean" => "INTEGER", // SQLite uses 0/1 for booleans
                    _ => "TEXT"
                };
                columns.Add($"`{columnName}` {sqlType}");
            }

            var createTableSql = $"CREATE TABLE IF NOT EXISTS `{safeTableName}` ({string.Join(", ", columns)});";

            Console.WriteLine($"[RUNE] Executing SQL: {createTableSql}");

            // Execute the command against the database
            await db.ExecuteAsync(createTableSql);

            return Results.Ok($"Table '{safeTableName}' created successfully in the database!");
        });

        runeGroup.MapGet("/{tenantId:guid}/schemas",
        async (Guid tenantId, IDbConnection db) =>
        {
            var tables = await db.QueryAsync<string>(
                "SELECT name FROM sqlite_master WHERE type='table' AND name LIKE @prefix;",
                new { prefix = $"{tenantId}_%" });

            var allSchemas = new Dictionary<string, List<dynamic>>();
            foreach (var fullTableName in tables)
            {
                // Remove the tenantId prefix for a clean name in the UI
                var cleanTableName = fullTableName.Replace($"{tenantId}_", "");
                var columns = await db.QueryAsync($"PRAGMA table_info('{fullTableName}');");
                allSchemas[cleanTableName] = columns.AsList();
            }

            return Results.Ok(allSchemas);
        });


        runeGroup.MapGet("/{tenantId:guid}/definitions.ts",
            async (Guid tenantId, IDbConnection db) =>
            {
                var tsBuilder = new StringBuilder();
                var tables = await db.QueryAsync<string>(
                    "SELECT name FROM sqlite_master WHERE type='table' AND name LIKE @prefix;",
                    new { prefix = $"{tenantId}_%" });

                var schema = new Dictionary<string, List<dynamic>>();
                foreach (var tableName in tables)
                {
                    schema[tableName] = (await db.QueryAsync($"PRAGMA table_info('{tableName}');")).AsList();
                }

                // Append the new, more detailed helper types
                tsBuilder.AppendLine("""
                // This file is auto-generated by TinyHind. DO NOT EDIT.
                
                type WhereOperator = 'eq' | 'neq' | 'gt' | 'gte' | 'lt' | 'lte' | 'like';
                
                type WhereClause<T extends keyof DbSchema> = {
                    [K in keyof DbSchema[T]]?: Partial<Record<WhereOperator, DbSchema[T][K]>>;
                };
                
                type OrderByClause<T extends keyof DbSchema> = {
                    [K in keyof DbSchema[T]]?: 'asc' | 'desc';
                };
                
                export interface Query<T extends keyof DbSchema> {
                    from: T;
                    select?: (keyof DbSchema[T])[];
                    where?: WhereClause<T>;
                    orderBy?: OrderByClause<T>;
                    limit?: number;
                    offset?: number;
                }
                """);

                // Generate the main DbSchema interface (this part is unchanged)
                tsBuilder.AppendLine("export interface DbSchema {");
                foreach (var table in schema)
                {
                    var cleanTableName = table.Key.Replace($"{tenantId}_", "");
                    tsBuilder.AppendLine($"  {cleanTableName}: {{");
                    foreach (var column in table.Value)
                    {
                        var tsType = (column.type as string)?.ToUpper() switch
                        {
                            "INTEGER" or "REAL" => "number",
                            "TEXT" => "string",
                            _ => "any"
                        };
                        tsBuilder.AppendLine($"    {column.name}: {tsType};");
                    }
                    tsBuilder.AppendLine("  };");
                }
                tsBuilder.AppendLine("}");

                return Results.Text(tsBuilder.ToString(), "application/typescript");
            });


    }
}